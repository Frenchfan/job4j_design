# job4j_design
Junior level educational projects - job4j, February 2022
The project will encompass a profound study and pet project, demonstrating the key notions in Java, like data structures (Collections, Map) and algorythms, 
logging, sockets, serialization, setting PostGreSQL, JDBC. Additional information on the pet project details is to be added while studying and practicing

[Generics, wild card, bounded and lower bounded wildcard](https://github.com/Frenchfan/job4j_design/commit/70b970f7d318c0db728e59d5f85abff4d9fe7a2d) - extends the strictly predefined use of types by implementing the <?> (wildcard) approach, which helps reating universal methods.

## Collections Pro

#### part 1. [Collections Lite](CollectionsLite.md#collections-lite)

[1. Что такое дженерики?](#1-Что-такое-дженерики)

[2. Типы дженериков?](#2-Типы-дженериков)

[3. Где хранится информация про Generics?](#3-Где-хранится-информация-про-Generics)

[4. Как можно получить тип Generics?](#4-Как-можно-получить-тип-Generics)

[5. Что такое итератор?](#5-Что-такое-итератор)

[6. Что такое коллекции?](#6-Что-такое-коллекции)

[7. Назовите базовые интерфейсы коллекций?](#7-Назовите-базовые-интерфейсы-коллекций)

[8. Расскажите реализации интерфейса List?](#8-Расскажите-реализации-интерфейса-List)

[9. Расскажите реализации интерфейса Set?](#9-Расскажите-реализации-интерфейса-Set)

[10. Расскажите реализации интерфейса Map?](#10-Расскажите-реализации-интерфейса-Map)

[11. Отличие ArrayList от LinkedList?](#11-Отличие-ArrayList-от-LinkedList)

[12. Отличие Set от List?](#12-Отличие-Set-от-List)

[13. Расскажите про методы Object hashCode и equals?](#13-Расскажите-про-методы-Object-hashCode-и-equals)

[14. Расскажите про реализации Map?](#14-Расскажите-про-реализации-Map)

[15. Расскажите, что такое коллизии в Map? Как с ними бороться?](#15-Расскажите-что-такое-коллизии-в-Map-Как-с-ними-бороться)

[16. Расскажите, что такое анализ алгоритма?](#16-Расскажите,-что-такое-анализ-алгоритма)

[17. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#17-Какая-временная-сложность-алгоритмов-добавления,-замены-и-удаления-в-каждой-из-коллекций-С-чем-связаны-отличия)

[18. Расскажите реализации данных очередей и стеков?](#18-Расскажите-реализации-данных-очередей-и-стеков)

[19. Расскажите про реализации деревьев?](#19-Расскажите-про-реализации-деревьев)

[20. Что такое loadFactor?](#20-Что-такое-loadFactor)

[21. Пример какова сложность поиска значения по ключу?](#21-Пример-какова-сложность-поиска-значения-по-ключу)

[22. Расскажите правило для переопределения метода hashCode?](#22-Расскажите-правило-для-переопределения-метода-hashCode)

[23. Приведите пример переопределения hashCode?](#23-Приведите-пример-переопределения-hashCode)

[24. Как вычисляется hash функция от объекта в HashMap?](#24-Как-вычисляется-hash-функция-от-объекта-в-HashMap)

[25. Правила проверки при переопределении метода equals?](#25-Правила-проверки-при-переопределении-метода-equals)

[26. Как устроена HashMap?](#26-Как-устроена-HashMap?)

[27. Какое начальное количество корзин в HashMap?](#27-Какое-начальное-количество-корзин-в-HashMap)

[28. Какая оценка временной сложности выборки элемента из HashMap? Гарантирует ли HashMap указанную сложность выборки элемента?](#28-Какая-оценка-временной-сложности-выборки-элемента-из-HashMap-Гарантирует-ли-HashMap-указанную-сложность-выборки-элемента)

[29. Роль equals и hashCode в HashMap?](#29-Роль-equals-и-hashCode-в-HashMap)

[30. Как и когда происходит увеличение количества корзин в HashMap?](#30-Как-и-когда-происходит-увеличение-количества-корзин-в-HashMap)

[31. Как работает HashMap?](#31-Как-работает-HashMap)

[32. Что такое хеш таблицы?](#32-Что-такое-хеш-таблицы)

[33. Что такое красно-черное дерево?](#33-Что-такое-красно-черное-дерево)

[34. Удаление элемента из дерева?](#34-Удаление-элемента-из-дерева)

[35. Какие существуют алгоритмы обхода дерева?](#35-Какие-существуют-алгоритмы-обхода-дерева)

## 1. Что такое дженерики?

Generics (обобщения) - это параметризованные типы. Они позволяют объявлять классы, интерфейсы и методы, где тип данных, которыми они оперируют, указан в виде параметра. Используя обобщения, можно, например, создать единственный класс, который будет автоматически обращаться с разнотипными данными. Классы, интерфейсы или методы, оперирующие параметризованными типами, называются обощенными.

До появления механизма обощения применялись ссылки типа Object (суперкласс для всех остальных классов). Но они не могли обеспечить типовую безопасность. Обобщения также избавили от необходимости явного приведения типов, теперь это происходит неявно или автоматически.

На практике, компилятор удаляет все сведения об обобщенных типах (этот процесс называется *стиранием*), выполняя необходимые операции приведения типов, чтобы сделать поведение прикладного кода таким, как будто создана конкретная версия класса Gen.

Обобщения работают **только с ссылочными типами**.
<details>
    <summary>Пример</summary>
     
 ```java    
     package ru.job4j.generics;       
     public class Gen<T> { 
         T ob; 
      
         /** 
          * Demonstrating generics 
          * @param ob 
          */ 
         public Gen(T ob) { 
             this.ob = ob; 
         } 
      
         public T getOb() { 
             return ob; 
         } 
      
         void showType() { 
             System.out.println("Типом T является " + ob.getClass().getName()); 
         } 
     }
    
    package ru.job4j.generics; 
      
     public class GenDemo { 
         public static void main(String[] args) { 
             Gen<Integer> iOb; 
             //Обрати внимание на автоупаковку для инкапсуляции значения 
             iOb = new Gen<>(88); 
             iOb.showType(); 
             int v = iOb.getOb(); 
             System.out.println("Значение: " + v); 
             System.out.println(); 
             Gen<String> strOb = new Gen<>("Тест обобщений"); 
             strOb.showType(); 
             String str = strOb.getOb(); 
             System.out.println("Значение: " + str); 
         } 
     }   
 ```
</details>    

Из примера выше нельзя провести следующую операцию:

~~iOb = strOb~~

Несмотря на то, что iOb и strOb относятся к типу Gen<T>, они являются ссылками на разные типы объектов, потому что их параметры типов отличаются. Этим, в частности, обощения обеспечивают типовую безопасность.

**Благодаря обобщениям ошибки, возникающие во время выполнения, преобразуются в ошибки, обнаруживаемые во время компиляции**.

- **Обобщения могут быть с 2-мя и более параметрами.** 
<details>
    <summary>Пример</summary>
    
```java
    class TwoGen<T, V> {
    	T ob1;
    	V ob2;
    
    	TwoGen(T o1, V o2) {
    		ob1 = o1;
    		ob2 = o2;
    	}
    
    	void showTypes() {
    		System.out.println(”Type T: “ + ob1.getClass().getName());
    		System.out.println(Type V: “ + ob2.getClass().getName());
    	}
    
    	T getob1() {
    		return ob1;
    	}
    
    	V getob2() {
    		return ob2;
    	}
    }
    
    class SimpleGen {
    
    	public static void main(String args[]) {
    		TwoGen<Integer, String>(tgObj = new TwoGen<Integer, String>(88, “Обобщения”);
    		tgObj.showTypes();
    		int v = tgObj.getob1();
    		System.out.println(”Значение: ” + v);
    		String str = tgObj.getob2();
    		System.out.println(”Значени” + str);
    	}
    }
```
</details>  

Свойства дженериков: **строгая типизация, единая реализация, отсутствие информации о типе**.

!!! Нельзя создать массив параметра типа ~~T[] array~~; нельзя создать массив generic классов (~~List<Integer>[] lists = **new** List<Integer>[10]~~). Но можно создать коллекцию коллекций (список списков).

Обощенные методы могут быть и в необобщенных классах. Вот пример объявления: `static <T extends Comparable<T>, V extends T> boolean isIn(T x, V[] y) {` Параметр типа объявляется **до типа, возвращаемого методом**. T и V связаны,чтобы гарантировать совместимость аргументов! Интерфейс Comparable является обощенным. Пример полностью - 
[Generics - non-generic class](https://github.com/Frenchfan/job4j_design/commit/70b970f7d318c0db728e59d5f85abff4d9fe7a2d)

**Конструкторы также могут быть обобщенными** вне обощенного класса. `<Т extends NumЬer> GenCons(T arg) {`. Пример: 
[Generic constructor](https://github.com/Frenchfan/job4j_design/commit/a68926b6d9a83d610079e979d203af2d265f3083)

By convention, type parameter names are single, uppercase letters. This stands in sharp contrast to the variable [naming](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html#naming) conventions that you already know about, and with good reason: Without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name.

**Обобщенными могут быть и интерфейсы**. Пример объявления: `interface MinMax<T extends Comparable<T>> {}`

Обрати внимание на ограничение T сверху. Объявление класса, реализующего интерфейс, выглядит следующим образом:

`class MyClass<T extends Comparable<T>> implements MinMax<T> {}`

После implements не нужно вновь описывать T - ограничение по нему уже есть в объявлении интерфейса, нужно лишь показать, что это обобщенный интерфейс. 

Как правило, класс, реализующий обобщенный интерфейс, **должен быть также обобщенным**. Иначе нельзя передать параметр типа. Однако, если после implements указать конкретный тип данных, то можно этого избежать:

`class MyClass implements MinMax<Integer> {}`

Преимущества обобщенных интерфейсов:

- может быть реализован для разных типов данных
- позволяет наложить ограничение

Пример с интерфейсом полностью:

[Generic interface](https://github.com/Frenchfan/job4j_design/commit/264ea555a5aca8daa0832aeae3cd69c470effc2c)

**Базовый тип и унаследованный код**. Для совместимости с написанным ранее кодом допускается создание создавать экземпляры дженериков без параметров:

`Gen raw = new Gen(new Double(98.6));` Проблема такого подхода - отсутствие типовой безопасности. 

**Сравнение типов в обощенной иерархии во время выполнения**

Для получения сведений о типе во время выполнения служит оператор instanceof - определяет, является ли объект экземпляром класса (тип значения - boolean).

 instanceof выдаст true, если объект дочернего обощенного класса сравнивается с суперклассом (родительским). При этом нельзя сравнивать объект обощенного класса с конкретным объектом - Gen<Integer> вместо Gen<?> - во время выполнения нет инфо о классе. 

[Generic and instanceof](https://github.com/Frenchfan/job4j_design/commit/fd5aca72bcddae05835b656fdd587dad07d98e4e)

**Приведение типов**

Тип одного экземпляра обобщенного класса можно привести к другому только в том случае, если они совместимы и их аргументы типа одинаковы. 

**Переопределение методов в обобщенном классе**

Никаких особенностей, переопределяются методы как у обычных классов:

[Overriding generics](https://github.com/Frenchfan/job4j_design/commit/247c9b288de2973c01f45c635954d09ed399ac2f)

Начиная с JDK7 можно не дублировать тип аргументов, а использовать ромбовидный оператор:

`MyClass<Integer, String> mcOb = new MyClass<>(98, "Line");` 

Нужно также очень аккуратно подходить к перегрузке методов обобщенных классов, чтобы избежать ощибок неоднозначности - 2 разных буквы в generic методе могут обозначать один и тот же тип,поэтому перегрузка бессмысленна при разделении этих букв на 2 варианта метода. Лучше дать им разные названия.

**Невозможно объявить статические поля в обобщенных классах**

``GenB<?>[] gens = new GenB<?>[10];` - **вот так объявляем массив элементов обобщенного класса**

**Создать обобщенные классы исключений нельзя. Обобщения не могут расширять Throwable**

By convention, type parameter names are single, uppercase letters. This stands in sharp contrast to the variable [naming](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html#naming) conventions that you already know about, and with good reason: Without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name.

The most commonly used type parameter names are:

- E - Element (used extensively by the Java Collections Framework)
- K - Key
- N - Number
- T - Type
- V - Value
- S,U,V etc. - 2nd, 3rd, 4th types - [https://docs.oracle.com/javase/tutorial/java/generics/types.html](https://docs.oracle.com/javase/tutorial/java/generics/types.html)

наглядно из Effective Java:

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/pro_1.png)

[к оглавлению](#Collections-Pro)

## 2. Типы дженериков?

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/pro_1.png)
Существует 2 типа дженериков:

- **<Т> Обычные дженерики (параметризованные типы)** - представляет возможность указать в классе или методе неопределенный тип или несколько типов, дать ему имя, которое в дальнейшем можно использовать в рамках класса или метода, как эквивалентное оригинальному типу.
    
    Может быть использован с ключевым словом `extends`, ограничен этим классом и его наследниками. Также можно использовать & и/или | указать несколько классов и/или интерфейсов. Поддерживает рекурсивное расширение типов. Пример:
    
    [Bounding Generics from top](https://github.com/Frenchfan/job4j_design/commit/8f05cc2c1c79fc57463f0caecd82b5771b4345a3)
    

`public static class NumberContainer<T extends Number & Comparable> {` Если ограничиваем классом и интерфейсами,то класс должен быть первым. 

- **Wildcard (подстановочные типы или маски (метасимвол подстановки `<?>`)** - используются в сигнатуре методов, но для параметризации класса - нет! Может быть использован в сочетании с ключевыми словами `extends` и `super`. Если в сигнатуре метода использовать generic с обозначением T (`boolean sameAvg(Stats<T> оb)`), то сравнение будет возможно только если за T будут однотипные аргументы, но это нарушает принцип обобщенного подхода. Замена - wildcards (маски / метасимвольный аргумент). `boolean sameAvg(Stats<?> оЬ)` дает возможность сравнить действительно любые аргументы - нет ограничений (unbounded wildcard).

Делятся на три типа:

- Upper Bounded Wildcards `<? extends Number>` - используется определенный тип и все его подтипы. Это ограничение сверху.
- Unbounded Wildcards `<?>` - без ограничений. Например, при сравнении двух значений классов Stats<Integer> и Stats<Short> (см. примеры выше) нельзя использовать просто Stats<T> - аргументы могут быть лишь одного и того же типа. А  вот если указать Stats<?>, то можно, либо можно указать `Stats<? extends Number>?`, если нужно подчеркнуть что это цифры. Пример:

[Bounding Generics - additional samples](https://github.com/Frenchfan/job4j_design/commit/8e96a7393dae4705d18947735126867dc751e371)

- Lower Bounded Wildcards `<? super Integer>` - работает с суперклассами (родительскими классами) конкретного класса - ограничение снизу. **Это исключающее выражение, не включает заданный подкласс**

Для выбора типа используют принцип PECS (`Producer Extends` `Consumer Super`)

- `extends` - когда надо только получать данные из объекта. Метод передает данные в аргумент.
- `super` - когда надо надо только вставлять данные в объект. Метод читает данные из аргумента.
- не использовать `wildcard`, когда требуется и получать и вставлять данные в структуру.

[к оглавлению](#Collections-Pro)

## 3. Где хранится информация про Generics?

Только в исходном коде до момента компиляции.

[к оглавлению](#Collections-Pro)

## 4. Как можно получить тип Generics?

ob.getClass().getName() - отобразит текущий тип дженерика.

Для получения сведений о типе во время выполнения служит оператор instanceof - определяет, является ли объект экземпляром класса (тип значения - boolean).

 instanceof выдаст true, если объект дочернего обощенного класса сравнивается с суперклассом (родительским). При этом нельзя сравнивать объект обобщенного класса с конкретным объектом - Gen<Integer> вместо Gen<?> - во время выполнения нет инфо о классе. 

[Generic and instanceof](https://github.com/Frenchfan/job4j_design/commit/fd5aca72bcddae05835b656fdd587dad07d98e4e)

`Class<T> t = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];` - ???

[к оглавлению](#Collections-Pro)

## 5. Что такое итератор?

Это интерфейс или объект классса, реализующего интерфейс, который обеспечивает общий, стандартизированный способ поочередного доступа ко всем элементам коллекции, или проще - это способ перебора содержимого коллекций. Каждая коллекция предоставляет свой итератор. Речь идеь, как правило, об одном из 2-х интерфейсов: **Iterator** (перебор коллекции,удаление и извлечение элементов) ****или **ListIterator** (двусторонний обход списка и видоизменение элементов). Основные методы **Iterator**:

- `default void` `forEachRemaining(Consumer<? super E> действие)` - выполняет заданное действие над каждым необработанным элементом коллекции
- `boolean hasNext()` - существует ли следующий элемент.
- `E next()` - возвращает сам элемент. Если элемента нет - `NoSuchElementException`
- `void remove()` - удаляет текущий элемент

Основные методы **ListIterator (можно изменить элементы, только для коллекций, реализующих интерфейс List, есть возможность прохода по коллекции вперед и назад)**:

- `void add(E объект)` - вводит заданный объект перед элементом, который должен быть возвращен в результате последующего вызова метода next()
- `default void` `forEachRemaining(Consumer<? super E> действие)` - выполняет заданное действие над каждым необработанным элементом коллекции
- `boolean hasNext()` - существует ли следующий элемент.
- `boolean hasPrevious()` - существует ли следующий элемент.
- `E next()` - возвращает следующий элемент. Если элемента нет - `NoSuchElementException`
- `int nextIndex()` - возвращает индекс следующего элемента в списке. Если следующий элемент отсутствует, то возвращается длина списка
- `E previous()` - возвращает предыдущий элемент. Если элемента нет - `NoSuchElementException`
- `int previousIndex()` - возвращает индекс предыдущего элемента в списке. Если предыдущий элемент отсутствует, то возвращается -1
- `void remove()` - удаляет текущий элемент. Если вызывается до методов next() или previous(), то генерируется исключения типа `IllegalStateException`
- `void set(E объект)` - присваивает заданный объект текущему элементу списка. Это элемент, возвращаемый в результате последнего вызова метода next() или previous().

Пример:

[Demonstrating Iterator and ListIterator](https://github.com/Frenchfan/job4j_design/commit/3e638c66eda9c7d83265fbf32246b43347f1014e)

Все коллекции также реализуют интерфейс `Iterable`, а, значит, их можно перебирать циклом for в стиле for each 

[Demonstrating For (Foreach) instead of Iterator](https://github.com/Frenchfan/job4j_design/commit/fae96d43558e21f3babb7cfe95f7f3b151257c5e)

С JDK8 появилась возможность для циклического обхода коллекции средствами интерфейса Spliterator. Этот интерфейс предоставляет методы, которые могут работать с коллекциями в несколько потоков параллельно. Кроме того, 2 метода (tryAdvance и forEachRemaining используют функциональный интерфейс).

[Demonstrating Spliterator](https://github.com/Frenchfan/job4j_design/commit/38e14ca62db340987d130c9ed67c8fc964d25393)


[к оглавлению](#Collections-Pro)

## 6. Что такое коллекции?

Коллекция - это динамически расширяемая группа объектов. В каркасе коллекций определяется ряд классов для управления такими коллекциями, как, например, списки и отображения. В зависимости от типа коллекции могут различаться время выполнения операции (поиска, вставки,удаления,изменения). Классы коллекций фактически способны обращаться с объектами любых типов.

[к оглавлению](#Collections-Pro)

## 7. Назовите базовые интерфейсы коллекций?

```
       Сollection          Map
            |
 --------------------
 |        |         |
Set     List     Queue
```

На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: `Collection` и `Map`. Эти интерфейсы разделяют все коллекции, входящие во фреймфорк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар "ключ - значение" соответственно.

Интерфейс `Collection` расширяют интерфейсы:

- `List` (список) - допустимы повторы, индексация происходит по мере добавления элементов
- `Set` (множество) - неуподрядоченная коллекция, в которой нет повторов
- `Queue` (односторонняя очередь) элементы удаляются только из начала списка
- дополнительно - SortedSet, NavigableSet (извлечение элементов по результатам поиска ближайшего совпадения), Deque (двусторонние очереди)

**Map** не расширяет интерфейс Collection, но входит в состав Collection API и предоставляет методы для работы с парами “ключ-значение

[к оглавлению](#Collections-Pro)

## 8. Расскажите реализации интерфейса List? стр 642 в книжке
```
     List I
        |
----------------------------
    |                       |
Vector   ArrayList     LinkedList
    |
Stack
```
Интересная особенность интерфейса - при вызове `add(int, E)` новый элемент появляется на указанной позиции, однако существующие не затираются, а смещаются вправо - фактически, происходит копирование списка. `Set` - присваивает значение элементу по индексу. Для массовой замены значение можно использовзать `replaceAll(UnaryOperator<E> opToApply)`. Есть метод сортировки (sort через компаратор) и `subList(int start, int finish)` - возвращает список, включающий элементы от start до **finish-1**.

Начиная с версии JDK9 есть фабричный метод of() для быстрого заполнения списка. Причем в этом методе **не допускаются null, список становится неизменяемым**.

**ArrayList. Расширяет AbstractList и реализует List.** В основе реализации этого класса лежит массив, который может менять свой размер, нет строгого требования указывать размерность при создании объекта ArrayList. *3 конструктора - пустой, с указанием коллекции, с указанием начальной емкости*. Еще несколько особенностей:

- может хранить элементы абсолютно любых типов (обобщенный интерфейс), но внутри одной коллекции возможен только один тип элементов (иначе - ClassCastException);
- элементы могут быть сохранены или извлечены по индексу их позиции в списке
- может хранить значения null
- допускает хранение дубликатов.
- `void add(int index, E object)`- добавляет объект на указанную позицию, все остальные объекты смещаются!, не перезаписываются)

некоторые выводы по ArrayList:

- быстрый доступ к элементам по индексу (O(1));
- доступ к элементам по значению за линейное время (O(n));
- реализации вставки и удаления элементов из "середины" списка - достаточно медленные и тяжелые;
- допускается хранение любых значений, в том числе и null (при этом null элементы и пустые ячейки разные вещи);
- размер списка - это количество элементов в нем, а не размер внутреннего массива
- Метод `ensureCapacity(int capacity)` позволяет заранее увеличить емкость списочного массива, чтобы оптимизировать использование оперативной памяти. А метод `trimToSize()` уменьшает размер массива до текущего количества хранящизся элементов.
- Метод `toArray()` позволяет преобразовать коллекцию в массив. Правильно указывать целевой массив при трансформации в качестве аргумента.
    
    `Integer myArray[] = new Integer[myArrayList.size()];`
    
    `myArray = myArrayList.toArray(myArray);`
    

**LinkedList**. Расширяет AbstractSequentalList и реализует интерфейсы List, Dequeue и Queue. Обобщенный. Также доступны элементы по индексам. *2 конструктора - с указанием начальной коллекции и пустой*

Доступны методы addFirst(), addLast(), getFirst(), getLast(), removeFirst(), removeLast().

**Vector.** Расширяет AbstractList, список на основе динамического массива. Не рекомендуется, если не требуется потокобезопасность.

**Stack**. Расширяет Vector (который расширяет AbstractList), реализация стека LIFO. Сейчас рекомендуется использовать реализации Deque, например,  ArrayDeque.

[к оглавлению](#Collections-Pro)

## 9. Расскажите реализации интерфейса Set?
```
                                  Set   <------------------  SortedSet I
                                   |                                 |
                        -----------|                          NavigableSet I
                        |          |                                 |
                    HashSet        TreeSet ---------------------->>---
                        |
                  LinkedHashSet
```
Интерфейс определяет множество, в котором не допускается дублирование элементов. Ключевой метод - add возвращает false при попытке добавить дублирующий элемент в множество. Как и в случае с List, есть фабричный метод of для быстрого заполнения множества. В рамках этого метода передается неизменяемое множество, в котором недопустимы null. 

ВЫбираем реализацию в соответствии с выдачей - если ваэен порядок получения элементов, LinkedHashSet, если не важен - 

**HashSet**. Расширяет класс AbstractSet и реализует интерфейс Set. Для создания коллекции, где для хранения элементов используется хеш-таблица. Для хранения данных в хеш-таблице применяется механизм хеширования, где содержимое ключа служит для определения однозначного значения, то есть хеш-кода. Этот хеш-код служит в качестве индекса, по которому сохраняются данные, связанные с ключом. Сам хеш-код недоступен. **Хеширование обеспечивает постоянство времени выполнения add(), contains(), remove() и size() даже для крупных множеств**. 

*4 конструктора - пустой, на основе коллекции, с начальной емкостью, с емкостью и коэффициентом заполнения.*

Коэффициент заполнения указывается в диапазоне от 0.0 до 1.0, определяет, насколько заполненным должно быть хэш-множество, прежде чем будет изменен его размер.

**Начальная емкость по умолчанию - 16**! **Коэффициент заполнения по умолчанию - 0.75**!

Также обобщенный. Не обеспечивает упорядоченность элементов, поскольку сам процесс хеширования обычно не приводит к созданию отсортированных множеств. 

**LinkedHashSet**. Расширяет класс HashSet, не доавляя новых методов. Обеспечивает связный список элементов в том порядке, в каком они введены в него. Соответственно, итерация тоже производится в определенном порядке. 

**Класс TreeSet**. Расширяет AbstractSet и реализует интерфейс NavigableSet. Применяется древовидная структура для хранения данных. Объекты сохраняются в отсортированном порядке по нарастающей. Время доступа и извлечения элементов достаточно мало - это хороший выбор для хранения больших объемов отсортированных данных, которые нужно быстро найти. Является обощенным классом. 

*4 конструктора - пустой (естественной порядок соритровки), на базе коллекции, с указанием компаратора и на базе отсортированного множества.*

Интересен метод subSet(”C”, “F”) - вырежет множество элементов между C и F (исключительно!). 

**Класс EnumSet**. Расширяет AbstractSet и реализует интерфейс Set. Служит для создания множества, предназначенного для применения вместе с ключами перечислимого типа enum. Обобщенный. **Без конструкторов**. Используются фабричные методы.

[к оглавлению](#Collections-Pro)

## 10. Расскажите реализации интерфейса Map?

+ **`HashMap`** - не синхронизированная хэш-таблица (быстрая).

+ **`LinkedHashMap`** - упорядоченная хэш-таблица с порядком итерирования в порядке добавления.

+ **`TreeMap`** - Упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратов в конструкторе. 

Подробнее
```
                                Map I
                                  |
          ----------------------------------------------------------
          |          |               |                    |
WeakHashMap     Hashmap        SortedMap I              HashTable
                                     |
                               NavigableMap I
                                     |
                                  TreeMap
```
Это наборы в виде пар “ключ-значение”. Ключи могут быть однозначными, а значения - дублироваться. Все классы, реализующие Map, не реализуют интерфейс Iterable. Значит, **их нельзя перебрать через цикл или получить итератор**. Но можно получить представление отображения в виде коллекции, которое допускает перебор содержимого в цикле или с помощью итератора. 

Интерфейс **Map**. Обобщенный `interface Map<K, V>`.Стр 673 Шилдта. Ключевые методы:

- `compute(K k, BiFunction<? super K, ? super V, ? extends V>)` - вызывает функицю для построения нового значения. Если функиця генерирует отличное от null значение, вводится новая пара ключ-значение (с ключом k), удаляется ранее существовавшая пара и возвращается новое значение. Если генерируется null, то удаляется ранее существовавшая пара и возвращается null.
- `computeIfAbsent(K k, BiFunction<? super K, ? super V, ? extends V>)` - возвращает значение, связанное с ключом k (не равное null), либо, если ключа нет, создает новое в соответствии с функцией (лямбда) и возвращает его.
    
    [ComputeIfAbsent sample](https://github.com/Frenchfan/job4j_design/commit/fe88ff3300b8106eec55e5538c61b5bf2bbd2ba8)
    
- `computeIfPresent(K k, BiFunction<? super K, ? super V, ? extends V>)` - возвращает новое значение, связанное с ключом k (не равное null), созданное в соответствии с функцией. Если его там нет - функция не выполняется.
- `clear` - удаляет все парыл ключ-значения
- `containsKey(Object k)` - true, если в map есть этот ключ
- `containsValue(Object v)` - true, если в map есть значение
- `Set<Map.Entry<K, V>> entrySet()` - возвращается множество типа Set, содержащее все записи в виде объектов Map.Entry.
- `equals(Object o)` - сравнивает на идентичность с другим map
- `forEach(BiConsumer<? super K, ? super V>` - выполняет заданное действие над каждым элементом отображения.
- `get(Object k)` - возвращает значение,связанное с ключом k
- `getOrDefault(Object k, V значение_по_умолчанию)` - возвращает значение,связанное с ключом k, либо значение по умолчанию
- `int hashCode()` - хеш-код мапа
- `boolean isEmpty()` - возвращает true, если мапа пустая
- `Set<k> keySet()` - возвращает множество ключей из map
- `merge(K k, V v, BiFunction<? super V, ? super V extends V>` - совмещает старое значение по ключу k и новое в соответствии с лямбда функцией. Если нет ключа k, то в map вводится новая пара из аргументов k и v.
    
    ```java
    Map<String, String> map = new HashMap<>();
    map.put("question", "Bla?");
    map.merge("question", " Blabla", (oldVal, newVal) -> oldVal + newVal);
    System.out.println(map.get("question")); // Bla? Blabla
    ```
    
- `putAll(Map<? extends K, ? extends V> m)` - вводит все записи из заданной map в вызывающую
- `put(K k, V v)` - добавляет новую пару ключ-занчение
- `default V putIfAbsent(K k, V v)` - вводит пару ключ-значение, если она отсутствует, возвращает старое значение, или, если значение,связанное с ключом, пустое, вводит новое и возвращет null.
- `remove(Object k)` - удаляет запись по ключу k
- `boolean remove(Object k, Object v)` - если такая пара есть, она удаляется и возвращается результат
- `default boolean replace(K k, V прежнее значение, V новое значение)` - если аданный ключ есть, то по нему заменяется значение
- `default void replaceAll(BiFunction<? super K, ? super V, ? extends V> функция)` - выполняет заданную функцию для каждого элемента мапа
- `int size()` - кол-во пар в мапе
- `Collection<V> values()` - возвращает коллекцию значений мапы.

Map или отбражения не реализуют интерфейс Collection, но являются частью каркаса коллекций. get() и put() - основнвые методы мапы. 

entrySet() - множество элементов мапы, keySet() - ключи. values() - возвращает коллекцию значений мапы.

Фабричный метод of() внедрен в интерфейс Map, начиная с JDK9. **При этом на допускаются null ключи или значения!**

Интерфейс **SortedMap** - интерфейс расширяет Map. Размещает записи по порядку нарастания ключей. Обобщенный. Наследует все методы их SortedMap. Дополнительные методы:

Для получения подотображений (частей мапы) есть методы `headMap(K конец)` - возвращает часть мапы с ключом меньше, чем указанный, `tailMap(K начало)` - возвращает часть мапы с ключом больше K, `subMap(K начало, K конец)` - часть мапы с началом больше “начало” и меньше “конец”. Подотображение поддерживается вызывающим - **изменилось одно, изменится и другое.** 

Для получения первого и последнего ключей следует вызывать `firstKey()`, `lastKey()`.

Интерфейс **NavigableMap**. Расширяет SortedMap, определяет поведение отображения, поддерживающего извлечение записей из него по наиболее точному совпадению с заданным ключом. Обобщенный. 

- `ceilingEntry(K object)` - ищет наименьший ключ k по критерию k≥объект. Если ключ найден, то возвращается запись по ключу, иначе - null
- `ceilingKey(K объект)` - аналогично, но возвращает ключ
- `descendingKeySet()` - возвращает множество типа NavigableSet, содержащее ключи в вызывающей мапе в обратном порядке, опирается на вызывающую мапу
- `descendingMap()` - возвращает обратную мапу
- `firstEntry()` - возвращает первую запись в отображении (мапе)
- `floorEntry(K object)` - ищет наибольший ключ k по критерию k≤объект. Если ключ найден, то возвращается запись по ключу, иначе - null
- `floorKey(K object)` - аналогично, но возвращает ключ
- `headMap(K верхняя граница, boolean включительно)` - возвращает мапу с ключами меньше, чем верхняя граница. boolean аргумент указывает, включить ли элемент, равный границе
- `higherEntry(K object)` - выполняет поиск наибольшего ключа (k > object) и возвращает пару ключ-значение
- `higherKer(K object)` - аналогично, возвращает только ключ
- `lastEntry()` - возращает последнюю пару ключ-значение
- `lowerEntry(K object)` - выполняет поиск наибольшего ключа (k < object) и возвращает пару ключ-значение
- `lowerKey(K object)` - аналогично k < object, возвращает только ключ
- `navigableKeySet()` - возвращает множество ключей из мапы типа NavigableSet
- `pollFirstEntry(), pollLastEntry()` - возвращает первую / последнюю пару ключ-значение, **попутно удаляя ее**
- `subMap(K нижняя граница, boolean включая_нижнюю_границу, K верхняя граница, boolean включая_верхнюю границу)` - возвращате NavigableSet по ключам меньше (или равно) верхней границы и больше (или равно) нижней границе. Результат опирается на вызывающую мапу.
- `tailMap(K нижняя граница, boolean включительно)` - возвращате NavigableSet по ключам больше (или равно) нижней границе. Результат опирается на вызывающую мапу.

**Интерфейс Map.Entry**. Обощенный. Статические методы:

- `comparingByKey()` - возвращает Comparator, сравнивающий записи по заданному ключу
- `comparingByValue()` - возвращает Comparator, сравнивающий записи по указанному значению

Нестатические методы:

- `boolean equals(Object object)` - возвращает true, если ключ и значения идентичные
- `getKey()` - возвращает ключ
- `getValue()` - возвращает значение
- `hashCode()` - хеш-код записи
- `setValue(V v)` - устанавливает указанное значение v в данной записи.

**Основные классы, реализующие Map**

**HashMap**. расширяет AbstractMap, реализует Map. Использует хеш-таблицу для хранения хешируемого отображения - обеспечивается постоянное время выполнения (O(1)) методов get() и put(). Обобщенный класс. 4 конструктора: без параметров, на базе мапы, с указанной емкостью, с указанной емкостью и коэффициентом заполнения(float))

**По умолчанию емкость 16, коэффициент заполнения - 0.75**

хеш-отображение не гарантирует порядок расположения своих элементов. Для вывода всех элементов можно использовать Map.Entry<K k, V v>

[HashMapSample](https://github.com/Frenchfan/job4j_design/commit/5b7f0cf7414adfe1455bb562b8fa316eb0ce48ca)

**TreeMap**. Расширяет класс AbstractMap и реализует интерфейс NavigableMap. В нем создается отображение, размещаемое в древовидной структуре. Все пары отсортированы, обеспечивается их быстрое извлечение. Древовидное отображение гарантирует,что его элементы будут отсортированы по порядку нарастания ключей. Обобщенный. 4 конструктора: без параметров, на базе мапы, с компаратором, на базе отсортированной мапы. Нет дополнительных методов. 

[TreeMapSample](https://github.com/Frenchfan/job4j_design/commit/0592d5e5ef63c956cd319f999ea64d44c18bdfb7)

LinkedHashMap. Расширяет HashMap. Создает связный список элементов, располагаемых в отображении в том порядке, в котором они вводились в него. Это позволяет организовать итерацию с вводом элементов в отображение в орпеделенном порядке. Обобщенный.  5 конструктора: без параметров, на базе мапы, с указанной начальной емкостью, с указанной начальной емкостью и коэффициентом заполнения, с указанной начальной емкостью  (по умолчанию - 16) , коэффициентом заполнения (п умолчанию, 0.75) и  boolean порядок. Только один! допоолнительный метод - removeEldestEntry().

IdentityHashMap. Расширяет AbstractMap, реализует интерфейс Map. При сравнении элементов в нем выполняется проверка ссылок на равенство. Не для общего применения. Обобщенный

EnumMap. Расширяет AbstractMap, реализует Map. ПЕрдназначен для применения с ключами перечислимого типа - класс К должен расширять класс Enum<K>. Обобщенный. 3 конструктора: на базе заданного типа ключей, на базе другой мапы, на базе мапы с ключами перечислимого типа

[к оглавлению](#Collections-Pro)

## 11. Отличие ArrayList от LinkedList?

**`ArrayList` - основан на динамическом массиве**, хранит свои элементы в массиве. 
(используют, если элементы чаще читаются, чем добавляются)

**+** Быстрая навигация по коллекции - осуществляется быстрый поиск элементов;

**+** меньше расходует памяти на хранение элементов;

**-** увеличение `ArrayList` происходит медленно;

**-** при вставке или удалении элемента в середину или в начало, приходится переписывать все элементы;
по умолчанию n = 10 (размер)

**`LinkedList` - двунаправленный список (цепочка)**, хранит элементы в объектах `Node<E>`, у которых есть ссылки на 
предыдущий и следующий элементы (используют, если элементы чаще добавляются, чем читаются). Доступны методы addFirst(), addLast(), getFirst(), getLast(), removeFirst(), removeLast(). 

**+** быстрая вставка и удаление в середину списка (переписать `next` и `previous` и всё);

**-** долгий поиск в середине (нужно перебрать все элементы) - за линейное время;

Очевидно, что плюсы одного являются минусами второго.
В среднем, сложности одинаковые, но все же ArrayList предпочтительнее использовать. 
`LinkedList` рекомендуется использовать, только когда преобладает удаление или вставка в начало или конец списка.

[к оглавлению](#Collections-Pro)

## 12. Отличие Set от List?

Динамические коллекции. 
Set - множество, повторы не допускаются. 
Вывод в HashSet не упорядочен, в LinkedHashSet - в порядке ввода. 
List - индексация элементов при вводе, обращение к ним по индексу, чего нет в Set из-за хеширования.

Set - множество, не хранит дубликаты.
List - список, может содержать дубли.
Set - множество уникальных объектов
в List могут храниться дубликаты, в Set - нет.
List - упорядоченная коллекция, а Set - нет.
В List может находиться сколько угодно null, а в Set максимум - один.
Set быстрее.
Например, реализация HashSet решает проблемы ArrayList и LinkedList в части скорости доступа и операций с элементами.

[к оглавлению](#Collections-Pro)

## 13. Расскажите про методы Object hashCode и equals?

Метод `hashCode()` используется для числового представления объекта, метод `equals()` для сравнения двух объектов.
При переопределении метода `equals()` всегда переопределяют `hashCode()`.
Если метод `equals()` возвращает `true`, то `hashCode()` всегда равны, но не наоборот, потому что 
возможны коллизии, когда для разных объектов будет одинаковый `hashCode()`. *"Множество объектов мощнее множества хеш-кодов."* 
Множество возможных хеш-кодов ограничено диапазоном примитивного типа `int` `2^32`, а множество объектов ничем не ограничено. 
    
**Метод `equals()` переопределяется так:** 
1. Не равны ли ссылки.
2. Не равен `null`.
3. Проверяем что объекты от одного класса.
4. Не равны ли `hashCode`.
5. Не равны состояния полей.
    
**Метод `hashCode()` переопределяется так:**
1. Простое нечетное число (31 популярно).
2. Умножаем результат на другое простое нечетное число (популярно 17).
прибавляем хэш-код поля, которое относится к бизнес логике.
3. Повторяем пункт 2 пока не кончатся поля которые относятся к бизнес-логике.

Правила equals
    Когда не нужно переопределять
    1. Когда каждый инстанс уникальный (Thread, Enum)
    2. Когда не потребуется определять уникальность (Random)
    3. Когда класс который вы расширяете уже имеет свою реализиацию (Например, для классов Set, List, Map реализация equals находится в AbstractSet, AbstractList и AbstractMap соответственно)
    4. когда класс приватный и вы уверен что equals никогда не будет вызван

    При переопределении нужно придерживаться правил:
    1. рефлексивность
        x.equals(x) = true
        если нарушить: не сможем найти объект, если положили его в коллекцию
    2. симметричность
        x.equals(y) = true => y.equals(x)
    3. транзитивность
        x.equals(y) = true && y.equals(z) = true => x.equals(z) = true
    4. согласованность \\ непротиворечивость
        x.equals(y) = true (всегда, при любом повторе)
    5. сравнение с null
        x.equals(null) = false

    Общий принцип переопределения:
    1. if (this == o) return true;
    2. if (o == null || getClass() != o.getClass()) return false;
    3. User user = (User) o;
    4. сравнить все значимые поля:
        -- примитивные типы через =
        -- ссылочные поля через equals()
        -- массивы либо в цикле либо Array.equals()
        -- float \\ double через методы оберточных классов *.compare()

[к оглавлению](#Collections-Pro)

## 14. Расскажите про реализации Map?

Выбор реализации зависит от того, что в каком порядке нам нужно выводить элементы - если порядок не важен, берем HashMap, если важен - LinkedHashMap, если нужны отсортированные элементы - TreeMap. 
При добавлении в Map нового элемента по хешированию происходит определение бакета. Если бакет пустой - метод equals вызываться не будет. 

**HashMap**. расширяет AbstractMap, реализует Map. Использует хеш-таблицу для хранения хешируемого отображения - обеспечивается постоянное время выполнения (O(1)) методов get() и put(). Обобщенный класс. 4 конструктора: без параметров, на базе мапы, с указанной емкостью, с указанной емкостью и коэффициентом заполнения(float))

**По умолчанию емкость 16, коэффициент заполнения - 0.75**

хеш-отображение не гарантирует порядок расположения своих элементов. Для вывода всех элементов можно использовать Map.Entry<K k, V v>

[HashMapSample](https://github.com/Frenchfan/job4j_design/commit/5b7f0cf7414adfe1455bb562b8fa316eb0ce48ca)

**TreeMap**. Расширяет класс AbstractMap и реализует интерфейс NavigableMap. В нем создается отображение, размещаемое в древовидной структуре. Все пары отсортированы, обеспечивается их быстрое извлечение. Древовидное отображение гарантирует,что его элементы будут отсортированы по порядку нарастания ключей. Обобщенный. 4 конструктора: без параметров, на базе мапы, с компаратором, на базе отсортированной мапы. Нет дополнительных методов. 

[TreeMapSample](https://github.com/Frenchfan/job4j_design/commit/0592d5e5ef63c956cd319f999ea64d44c18bdfb7)

LinkedHashMap. Расширяет HashMap. Создает связный список элементов, располагаемых в отображении в том порядке, в котором они вводились в него. Это позволяет организовать итерацию с вводом элементов в отображение в орпеделенном порядке. Обобщенный.  5 конструктора: без параметров, на базе мапы, с указанной начальной емкостью, с указанной начальной емкостью и коэффициентом заполнения, с указанной начальной емкостью  (по умолчанию - 16) , коэффициентом заполнения (п умолчанию, 0.75) и  boolean порядок. Только один! допоолнительный метод - removeEldestEntry().

IdentityHashMap. Расширяет AbstractMap, реализует интерфейс Map. При сравнении элементов в нем выполняется проверка ссылок на равенство. Не для общего применения. Обобщенный

EnumMap. Расширяет AbstractMap, реализует Map. Предназначен для применения с ключами перечислимого типа - класс К должен расширять класс Enum<K>. Обобщенный. 3 конструктора: на базе заданного типа ключей, на базе другой мапы, на базе мапы с ключами перечислимого типа

[к оглавлению](#Collections-Pro)

## 15. Расскажите, что такое коллизии в Map Как с ними бороться?

**Хеширование** — преобразование массива входных данных произвольной длины в (выходную) битовую строку установленной длины, 
выполняемое по определенному алгоритму. Функция, воплощающая этот алгоритм и выполняющая преобразование, 
называется хеш-функцией. Хеш-код - это результат вычисления хеш-функции. 

Коллизия - это ситуация, когда не эквивалентные элементы имеют одинаковые хеш-коды. Возникает оттого, что количество 
значений хеш-функций меньше (ограничены диапазоном значений типа `int 2^32`), чем вариантов исходных данных. 
Вероятность возникновения коллизий оценивает качество хеш-функций.

В Java для разрешения коллизий используется модифицированный метод цепочек. Суть: когда количество элементов в корзине 
превышает определенное значение, данная корзина переходит от использования связного списка к использованию 
сбалансированного дерева. Но данный метод имеет смысл лишь тогда, когда на элементах хеш-таблицы задан линейный порядок. 
Т.е. при использовании данных типа `int` или `double` имеет смысл переходить к дереву поиска, а при использовании 
каких-нибудь ссылок на объекты не имеет, т.к. они не реализуют нужный интерфейс. 
Такой подход позволяет улучшить производительность с `O(n)` до `O(log(n))`. 
Данный способ используется в таких коллекциях как `HashMap`, `LinkedHashMap` и `ConcurrentHashMap`.

По простому:

**Коллизия** - это когда для двух объектов вычисляется одинаковый хеш-код.
 
Решение: проверить методом `equals()`, что ссылки на объекты не равны. 
Для хэш-таблицы в тот же бакет еще один объект, за счет того что каждый бакет - это связанный список.

[к оглавлению](#Collections-Pro)

## 16. Расскажите что такое анализ алгоритма?

Анализ алгоритма дает нам понимание того, сколько времени займет решение данной задачи при помощи данного алгоритма. 
Эффективность алгоритма оценивается его временной сложностью.

Временная сложность алгоритма – это функция, позволяющая определить, 
как быстро увеличивается время работы алгоритма с увеличением объёма данных.

Наиболее часто встречающиеся классы сложности:
+ `O(1)` – константная сложность (т.е. константное время);
+ `О(n)` – линейная сложность;
+ `О(nа)` – полиномиальная сложность;
+ `О(log(n))` – логарифмическая сложность;
+ `O(n*log(n))` – квазилинейная сложность;
+ `O(2n)` – экспоненциальная сложность;
+ `O(n!)` – факториальная сложность.

`ArrayList`: индекс - 0(1), поиск 0(n). вставка 0(n), удаление O(n).
`LinkedList`: индекс - 0(n), поиск 0(n). вставка 0(1), удаление O(1).
`Деревья (только бинарное дерево поиска)` для всех операций - O(log(n)).
`Хэш таблицы` - O(1) для всех операций, если не считать коллизии
Поиск в отсортированном массиве происходит за время O(log(n)). Вставка нового элемента в начало за время O(n).
Если есть константное время + линейная сложеность - то константу можно отбросить, сложнось будет линейная
Вложенный цикл - квадратичная сложность.

[к оглавлению](#Collections-Pro)

## 17. Какая временная сложность алгоритмов добавления, замены и удаления в каждой из коллекций С чем связаны отличия?

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/pro_2.png)

+ **`ArrayList`:** индекс - `O(1)`, поиск `O(n)`, вставка `O(n)`, удаление `O(n)`.

+ **`LinkedList`:** индекс - `O(n)`, поиск `O(n)`, вставка `O(1)`, удаление `O(1)`.

+ **Деревья** для всех операций - `O(log(n))`.

+ **Хэш таблицы** для всех операций - `O(1)`, если не считать коллизии.
Поиск в отсортированном массиве происходит за время O(log(n)). Вставка нового элемента в начало за время O(n).
Если есть константное время + линейная сложеность - то константу можно отбросить, сложнось будет линейная
Вложенный цикл - квадратичная сложность.
Справочник по Java Collections Framework https://habr.com/ru/post/237043/

[к оглавлению](#Collections-Pro)

## 18. Расскажите реализации данных очередей и стеков?

+ **`Queue` (FIFO)** - одностороняя очередь, элементы можно получить в том порядке в котором добавляли.

+ **`Dequeue`** - двусторонняя очередь, можно вставлять/получать элементы из начала и конца. 

+ **`Stack` (LIFO)** - стек, можно получить только последний элемент.

```
Queue<Integer> myQ = new LinkedList<Integer>();
```
```
Queue
   |
Deque
   |
  -----————-----
     |         |
LinkedList    ArrayDeque
```
**Queue** (одностороняя очередь) - когда элементы можно получить в том порядке в котором добавляли. FIFO
**Dequeue** (двусторонняя очередь) - можно вставлять/получать элементы из начала и конца.
**Stack** - можно получить только последний элемент LIFO

Базовым интерфейсом всех очередей Java является **Queue**.
Этот интерфейс описывает коллекции с предопределённым способом вставки и извлечения элементов, а именно — очереди FIFO (first-in-first-out).
Добавление элементов в очередь - методом add(), удаление - poll(), получение первого элемента без его удаления - peek().
Две самые простые реализации очереди - это LinkedList и PriorityQueue.

**Класс PriorityQueue**. Расширяет AbstractQueue и реализует интерфейс Queue. Является единственной прямой реализацией интерфейса Queue (была добавлена, как и интерфейс Queue, в Java 1.5), не считая класса LinkedList, который так же реализует этот интерфейс, но был реализован намного раньше. Особенностью данной очереди является возможность управления порядком элементов. Служит для создания очереди по приоритетам на основании компаратора очереди. Является обобщенным. 

6 конструкторов: пустой, с указанием емкости, с емкостью и компаратором, на базе коллекции, на базе другой PriorityQueue, на базе отсортированного множества (SortedSet). 

**Первоначальная емкость очереди по умолчанию равна 11!**

Класс **Stack**. Добавление элементов осуществляется методом push(), а удаление методом pop().

Интерфейс Deque позиционируется как современная альтернатива классу Stack.
**Интерфейс** **Deque** - это сокращение от «double ended queue» (двусторонняя очередь).
Технически Deque является расширением интерфейса очереди Queue.
Интерфейс Deque реализуют всё тот же LinkedList, а также ArrayDeque.
**ArrayDeque** — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out)
    peekFirst() — возвращает (но не удаляет из очереди) первый элемент, либо null. (есть аналог getFirst - генерирует исключение NoSuchElementException, если нет)
    peekLast() — возвращает (но не удаляет из очереди) последний элемент.
    pollFirst() — возвращает первый элемент из очереди и удаляет его.
    pollLast() — возвращает последний элемент из очереди и удаляет его.
    addFirst() — добавляет новый элемент в начало очереди.
    addLast() — добавляет элемент в конец очереди.

**Класс ArrayDequeue**. Расширяет AbstractCollection и реализует интерфейс Dequeue. Не добавляет новых методов. Обощенный. 3 конструктора: пустой, с указанием начальной емкости, на базе коллекции. 

**Первоначальная емкость - 16.** Методы push (добавление в очередь) и peek и pop (извлечение). 

`while (adq.peek() != null) {System.out.print(adq.pop() + " ");}`

[к оглавлению](#Collections-Pro)

## 19. Расскажите про реализации деревьев?

+ **`TreeMap`** - упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратор в конструкторе. 
Красно-черные дерево - это самобалансирующееся дерево, которое гарантирует логарифмический рост высоты дерева от числа узлов.

+ **`TreeSet`** - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию хеш-кодов. 
Можно управлять порядком при помощи компаратора.

[к оглавлению](#Collections-Pro)

## 20. Что такое loadFactor?

**loadFactor** - это коэффициент загрузки, равен соотношению `(размер коллекции / колличество элементов)`. 
При достижении порогового значения размер коллекции увеличивается.

Например, в хеш-таблице поле, которое показывает на сколько заполнен массив, на котором эта таблица основана. 
Если на 3/4, то создается новый массив с большим размером и данные перераспределяются. 

[к оглавлению](#Collections-Pro)

## 21. Пример какова сложность поиска значения по ключу?

**Пример:** разработчик создал класс
```java
class User {
    private int age;
    private String name;
    private String email;

@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    User user = (User) o;
    return age == user.age &&
    Objects.equals(name, user.name) &&
    Objects.equals(email, user.email);
}

@Override
public int hashCode() {
    return 1;
}
```
и затем создал 60 разных объектов которые использовал в качестве ключа в мапе
какова сложность поиска значения по ключу в таком случае и почему
java >= 1.8

**Ответ:**
Хеш-код у нас константа - худший вариант, т.е. все объекты находятся в одном бакете и хеш-таблица превращается в связный 
список со сложностью поиска `О(n)`. Т.к. версия java >= 1.8 то, когда количество элементов в бакете достигает 
определенной величины (`TREEIFY_THRESHOLD = 8`), вместо связанного списка используется сбалансированное дерево. 
Соответственно у нас `n=60 > 8`.

Поэтому в данном случае временная сложность поиска по ключу составит `О(log(n))`.

[к оглавлению](#Collections-Pro)

## 22. Расскажите правило для переопределения метода hashCode?

Необходимо перекрывать `hashCode` каждый раз, когда выполняется перекрытие `equals`, иначе программа может работать неправильно. 
Метод `hashCode` должен подчиняться общему контракту, определенному в `Object`, и выполнять разумную работу по назначению 
неравным экземплярам разных значений хеш-кодов. 

Главным условием при перекрытии метода `hashCode`: равные объекты должны давать одинаковый хеш-код. 
Два различных экземпляра с точки зрения метода `equals` могут быть логически эквивалентными, 
однако для метода `hashCode` класса `Object` оказаться всего лишь двумя объектами, не имеющими между собой ничего общего.

1. Объявить переменную типа `int` с именем `result` и инициализировать ее хеш-кодом с (identity hash code) 
для первого значащего поля объекта.

2. Для каждого из остальных значащих полей нужно:

    а. Вычислить хеш-код с типа `int` для такого поля.

    б. Объединить хеш-код с, вычисленный в п. 2, а, с `result` следующим образом: `result = 31 * result + с;`

3. Вернуть `result`.

Примечание: Производные поля можно из вычисления хеш-кода исключить, т.е. можно игнорировать любое поле, 
значение которого может быть вычислено из полей, включаемых в вычисления. Необходимо исключить любые поля, 
которые не используются в сравнении методом `equals`, иначе есть риск нарушить второе положение контракта `hashCode`. 
Умножение в п. 2б делает результат зависящим от порядка полей и дает гораздо лучшую хеш-функцию, 
если класс имеет несколько аналогичных полей. 
Значение 31 выбрано потому, что оно является нечетным простым числом, это традиционная практика, 
кроме того повышает производительность (умножение можно заменить сдвигом и вычитанием).

[к оглавлению](#Collections-Pro)

## 23. Приведите пример переопределения hashCode?

Например, переопределим `hashCode` для класса PhoneNumber:
```java
public final class PhoneNumber {
    private final short areaCode, prefix, lineNum;
    public PhoneNumber(int areaCode, int prefix, int lineNum) {
         this . areaCode = rangeCheck (areaCode, 999, ’’area code”);
         this.prefix = rangeCheck (pref ix, 999, ’’prefix’’);
         this.lineNum = rangeCheck(lineNum, 9999, "line num”);}

   // Типичный метод hashCode
   @Override public int hashCode() {
        int result = Short.hashCode(areaCode);
        result = 31* result + Short.hashCode(prefix);
        result = 31 * result + Short.hashCode(lineNum);
        return result;}

   // Однострочный метод hashCode с посредственной производительностью. Этот стиль хеш-функции рекомендуется использовать только в ситуациях, когда производительность не является критической.
   @Override public int hashCode() {
       return Objects.hash(lineNum, prefix, areaCode);}

   // Метод hashCode с отложенной инициализацией и кешированием хеш-кода. Если класс является неизменяемым, а стоимость вычисления хеш-функции имеет значение, вы можете подумать о хранении хеш-кода в самом объекте вместо того, чтобы вычислять его заново каждый раз, когда в нем появится необходимость.
   private int hashCode; // Автоматически инициализируется значением 0
  @Override public int hashCode() {
      int result = hashCode;
      if (result == 0) {
         result = Short.hashCode(areaCode);
         result =31* result + Short.hashCode(prefix) ;
         result =31* result + Short.hashCode(lineNum);
         hashCode = result;}
      return result;}

}
```

Контракт `hashCode` из спецификации `Object`:

+ Во время выполнения приложения при многократном вызове для одного и того же объекта метод `hashCode` 
должен всегда возвращать одно и то же целое число при условии, что никакая информация, 
используемая при сравнении этого объекта с другими методом equals, не изменилась. 
Однако не требуется, чтобы это же значение оставалось тем же при другом выполнении приложения.

+ Если два объекта равны согласно результату работы `equals(Object)`, то при вызове для каждого из них метода 
`hashCode` должны получиться одинаковые целочисленные значения.

+ Если метод `equals(Object)` утверждает, что два объекта не равны один другому, это не означает, что метод `hashCode` 
возвратит для них разные числа. Однако программист должен понимать, что генерация разных чисел для неравных 
объектов может повысить производительность хеш-таблиц.

[к оглавлению](#Collections-Pro)

## 24. Как вычисляется hash функция от объекта в HashMap?

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
в методе `hash()` cначала вычисляется промежуточное значение `h`, 
оно равно хеш-функции от ключа (для `HashMap` в базовой реализации `Object.hashCode()`), 
затем вычисляется значение, равное нулевому побитовому сдвигу числа `h` вправо на 16 бит с заполнением нулями 
(`>>>` все биты числа сдвигаются вправо на 16 позиций, освободившиеся биты заполняются нулями), 
и для вычисленных выше значений выполняется операция `XOR` (^ побитовое логическое или).

В методе коллекции, при поиске бакета/корзины/индекса хеш-код ключа делится с остатком (`%`) на размер хеш-таблицы 
(по умолчанию `n=16`) и результатом будет число в диапазоне от `0` до `n`, 
т.е. номер ячейки в массиве, куда помещается объект с нашим ключом. 
А т.к. для `HashMap` размер хеш-таблицы равен степени 2, то вместо `%n` (остатка от деления) 
используется более быстрый `&(n-1)` (побитовое И).

Т.е. вместо `index = hash % (n - 1)` используется `index = (n - 1) & hash`

Примечание: побитовый сдвиг `>>>` и операция `XOR` выполняются для того, 
чтобы старшие биты первоначального хеш-кода `h` в дальнейшем участвовали в `(n - 1) & hash` даже при небольшом кол-ве бакетов. 
Этим обеспечивают не само по себе наилучшее распределение в хеш-таблице, а страхуются от неудачной функции `hashcode()`.

**Итого:** Через `%` или `&` вычисляется "внешний" `hash` (находим бакет/корзину/индекс в массиве),
 через `>>>` "внутренний", который отвечает за усложение хеш-кода, подключая к формированию старшие биты.

[к оглавлению](#Collections-Pro)

## 25. Правила проверки при переопределении метода equals?

**1.** Используйте оператор `==` для проверки того, что аргумент является ссылкой на данный объект. 
Если это так, возвращайте `true`. Это просто оптимизация производительности, 
которая может иметь смысл при потенциально дорогостоящем сравнении.

**2.** Используйте оператор `instanceof` для проверки того, что аргумент имеет корректный тип. 
Если это не так, возвращайте `false`. Обычно корректный тип — это тип класса, которому принадлежит данный метод. 
В некоторых случаях это может быть некоторый интерфейс, реализованный этим классом. Если класс реализует интерфейс, 
который уточняет контракт метода `equals`, то в качестве типа указывайте этот интерфейс: 
это позволит выполнять сравнение классов, реализующих этот интерфейс. 
Подобным свойством обладают интерфейсы коллекций, таких как `Set`, `List`, `Мар` и `Map. Entry`.

**3.** Приводите аргумент к корректному типу. Поскольку эта операция следует за проверкой instanceof, она гарантированно успешна.

**4.** Для каждого “важного” поля класса убедитесь, что значение этого поля в аргументе соответствует полю данного объекта. Если все тесты успешны, возвращайте true; в противном случае возвращайте false. Если в п. 2 тип определен как интерфейс, вы должны получить доступ к полям аргумента через методы интерфейса; если тип представляет собой класс, вы можете обращаться к его полям непосредственно, в зависимости от их доступности.

Пример Класс с типичным методом `equals`:
```java
public final class PhoneNumber {
   private final short areaCode, prefix, lineNum;
   public PhoneNumber(int areaCode, int prefix, int lineNum) {
      this . areaCode = rangeCheck (areaCode, 999, ’’area code”);
      this.prefix = rangeCheck (pref ix, 999, ’’prefix’’);
      this.lineNum = rangeCheck(lineNum, 9999, "line num”);}
   private static short rangeCheck(int val, int max, String arg) {
      if (val < 0 || val > max)
         throw new IllegalArgumentException (arg 4- ": "4- val);
         return (short) val;

   @Override public boolean equals(Object о) {
      if (о == this) //1
         return true;
      if (! (o instanceof PhoneNumber)) //2
         return false;

//здесь насколько понял, мы нарушаем принцип подстановки Лисков и используем следующее

      if (о == null || o.getClass() != getClass ())
         return false;


      PhoneNumber pn = (PhoneNumber)o; //3
      return pn.lineNum == lineNum && pn.prefix == prefix && pn.areaCode == areaCode; //4
      }
... 
}
```
метод `equals` имеет смысл перекрывать, когда для класса определено понятие логической эквивалентности 
(logical equality), которая не совпадает с тождественностью объектов, а в суперклассе метод equals не перекрыт. 
В общем случае это происходит с классами значений (напр. `Integer` или `String`). 
Перекрывая метод `equals`, нужно соблюдать его общий контракт.

Метод `equals` реализует отношение эквивалентности, которое обладает следующими свойствами:

+ Рефлексивность: для любой ненулевой ссылки на значение `х` выражение `х.equals(х)` должно возвращать `true`.

+ Симметричность: для любых ненулевых ссылок на значения `х` и `у` выражение `х.equals(у)` должно возвращать `true` 
тогда и только тогда, когда `у.equals(х)` возвращает `true`.

+ Транзитивность: для любых ненулевых ссылок на значения `х`, `у` и `z`, если `х.equals(у)` возвращает `true` 
и `у.equals(z)` возвращает `true`, `х.equals(z)` должно возвращать `true`.

+ Непротиворечивость: для любых ненулевых ссылок на значения `х` и `у` многократные вызовы `х.equals(у)` должны либо 
постоянно возвращать `true`, либо постоянно возвращать `false` при условии, что никакая информация, 
используемая в сравнениях `equals`, не изменяется.

+ Для любой ненулевой ссылки на значение `х` выражение `х.equals(null)` должно возвращать `false`.

[к оглавлению](#Collections-Pro)

## 26. Как устроена HashMap?

**`HashMap`** состоит из «корзин» `bucket`. С технической точки зрения бакеты — это элементы массива, которые хранят ссылки 
на списки элементов. При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, на основании которого вычисляется 
номер корзины (номер ячейки массива), в которую попадет новый элемент. 

Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, 
то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, 
от которого и ставится ссылка на вновь добавленный элемент. 

Если в списке был найден элемент с таким же ключом, то он заменяется. Добавление, поиск и удаление элементов выполняется 
за константное время. Вроде все здорово, с одной оговоркой, хеш-функция должна равномерно распределять элементы 
по корзинам, в этом случае временная сложность для этих 3 операций будет не ниже `lg т`, 
а в среднем случае как раз константное время.

[к оглавлению](#Collections-Pro)

## 27. Какое начальное количество корзин в HashMap?

По умолчанию в `HashMap` 16 корзин. Отвечая, стоит заметить, что можно используя конструкторы с параметрами: 
через параметр `capacity` задавать свое начальное количество корзин

[к оглавлению](#Collections-Pro)

## 28. Какая оценка временной сложности выборки элемента из HashMap Гарантирует ли HashMap указанную сложность выборки элемента?

Если вы возьмете хеш-функцию, которая постоянно будет возвращать одно и то же значение, то `HashMap` превратится 
в связный список, с низкой производительностью.
 
Если вы будете использовать хеш-функцию с равномерным распределением, в предельном случае гарантироваться будет только 
временная сложность `lg n`. Так что, ответ на вторую часть вопроса — нет, не гарантируется.

[к оглавлению](#Collections-Pro)

## 29. Роль equals и hashCode в HashMap?

`hashCode` позволяет определить корзину для поиска элемента, а `equals` используется для сравнения ключей элементов 
в списке внутри корзины и искомого ключа.

[к оглавлению](#Collections-Pro)

## 30. Как и когда происходит увеличение количества корзин в HashMap?

Помимо `capacity` в `HashMap` есть еще параметр `loadFactor`, на основании которого, вычисляется предельное количество 
занятых корзин (`capacity*loadFactor`). По умолчанию `loadFactor = 0,75`. По достижению предельного значения, 
число корзин увеличивается в 2 раза. Для всех хранимых элементов вычисляется новое «местоположение» с учетом нового 
числа корзин.

[к оглавлению](#Collections-Pro)

## 31. Как работает HashMap?

HashMap has an inner class **Entry**:
```java
static class Entry<K ,V> implements Map.Entry<K, V> {
	final K key;
	V value;
	Entry<K ,V> next;
	final int hash;
}
```
**How HashMap.put() methods works:**

transient Entry[] table;		
1. First of all, the key object is checked for null. If the key is null, the value is stored in table[0] position. 
Because hashcode for null is always 0. 
2. Then on next step, a hash value is calculated using the key’s hash code by calling its hashCode() method. 
This hash value is used to calculate the index in the array for storing Entry object. 
JDK designers well assumed that there might be some poorly written hashCode() functions that can return very high or low hash code value.
To solve this issue, they introduced another hash() function and passed the object’s hash code to this hash() function 
to bring hash value in the range of array index size.
3. Now indexFor(hash, table.length) function is called to calculate exact index position for storing the Entry object.

**How collisions are resolved:**

as we know that two unequal objects can have the same hash code value, 
how two different objects will be stored in same array location called bucket.
The answer is LinkedList. If you remember, Entry class had an attribute "next". 
This attribute always points to the next object in the chain. This is exactly the behavior of LinkedList.

1. So, in case of collision, Entry objects are stored in linked list form. 
When an Entry object needs to be stored in particular index, HashMap checks whether there is already an entry?? 
If there is no entry already present, the entry object is stored in this location. 
If there is already an object sitting on calculated index, its next attribute is checked. 
If it is null, and current entry object becomes next node in linkedlist. 
If next variable is not null, procedure is followed until next is evaluated as null.

2. What if we add the another value object with same key as entered before. 
Logically, it should replace the old value. How it is done? Well, after determining the index position of Entry object, 
while iterating over linkedist on calculated index, HashMap calls equals method on key object for each entry object.

All these entry objects in linkedlist will have similar hashcode but equals() method will test for true equality. 
If key.equals(k) will be true then both keys are treated as same key object. 
This will cause the replacing of value object inside entry object only.

How HashMap.get() methods works:
```java
public V get(Object key) {
    if (key == null)
    return getForNullKey();
    int hash = hash(key.hashCode());
    for (Entry<K , V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) {
		Object k;
		if (e.hash == hash && ((k = e.key) == key || key.equals(k)))
			return e.value;
		}
		return null;
	}
}
```

[к оглавлению](#Collections-Pro)

## 32. Что такое хеш таблицы?

Хеш-таблицей называется структура данных, обеспечивающая очень быструю вставку и поиск. 
У хеш-таблиц также имеются свои недостатки. Они реализуются на базе массивов, а массивы трудно расширить после создания. 
У некоторых разновидностей хеш-таблиц быстродействие катастрофически падает при заполнении таблицы, 
поэтому программист должен довольно точно представлять, сколько элементов данных будет храниться в таблице 
(или приготовиться к периодическому перемещению данных в другую хеш-таблицу большего 
размера — процесс занимает довольно много времени).

Кроме того, при работе с хеш-таблицами не существует удобного способа перебора элементов в определенном 
порядке (скажем, от меньших к большим). Если вам необходима такая возможность, поищите другую структуру данных.

[к оглавлению](#Collections-Pro)

## 33. Что такое красно-черное дерево?

Красно-черные деревья относятся к сбалансированным бинарным деревьям поиска.
Как бинарное дерево, красно-черное обладает свойствами:

1) Оба поддерева являются бинарными деревьями поиска.

2) **Для каждого узла с ключом K выполняется критерий упорядочения:
ключи всех левых потомков <= K < ключи всех правых потомков**
(в других определениях дубликаты должны располагаться с правой стороны либо вообще отсутствовать). 
Это неравенство должно быть истинным для всех потомков узла, а не только его дочерних узлов.

Свойства красно-черных деревьев:
1) Каждый узел окрашен либо в красный, либо в черный цвет (в структуре данных узла появляется дополнительное поле – бит цвета).
2) Корень окрашен в черный цвет.
3) Листья(так называемые null-узлы) окрашены в черный цвет.
4) Каждый красный узел должен иметь два черных дочерних узла. Нужно отметить, что у черного узла могут быть черные 
дочерние узлы. Красные узлы в качестве дочерних могут иметь только черные.
5) Пути от узла к его листьям должны содержать одинаковое количество черных узлов(это черная высота).

Красно-черные деревья: коротко и ясно https://habr.com/ru/post/330644/

[к оглавлению](#Collections-Pro)

## 34. Удаление элемента из дерева?

Если у удаляемого элемента нет потомков или один потомок, то удалить просто. 
Если у удаляемого элемента есть два потомка, то удаляемый узел надо заменить на приемника. 
Т.к. используется сложный алгоритм для поиска приемника, то часто вместо удаления используют флаг `isDeleted`. 
В остальных методах проверяют значение этого флага.

[к оглавлению](#Collections-Pro)

## 35. Какие существуют алгоритмы обхода дерева?

В зависимости от траекторий выделяют два типа обхода:
+ горизонтальный (в ширину)
+ вертикальный (в глубину).

 **Горизонтальный** обход подразумевает обход дерева по уровням (level-ordered) – вначале обрабатываются все узлы 
текущего уровня, после чего осуществляется переход на нижний уровень.

```java
static void contLevelOrder(Node top) {
    Queue<Node> queue=new LinkedList<> ();
        do {
            top.treatment();
            if (top.left!=null) queue.add(top.left);
            if (top.right!=null) queue.add(top.right);
            if (!queue.isEmpty()) top=queue.poll();
    } while (!queue.isEmpty());
}
```
    
**Вертикальный** бывает 3 видов:
+ прямой (preorder)
    1. Посещение узла.
    2. Вызов самого себя для обхода левого поддерева узла.
    3. Вызов самого себя для обхода правого поддерева узла

+ симметричный (inorder). При симметричном обходе двоичного дерева все узлы перебираются в порядке возрастания ключей.
Простейший способ обхода основан на использовании рекурсии. 
Метод должен выполнить только три операции:
    1. Вызов самого себя для обхода левого поддерева узла.
    2. Посещение узла.
    3. Вызов самого себя для обхода правого поддерева узла. 
```java
private void inOrder(node localRoot) {
     if(localRoot != null) {
          inOrder(localRoot.leftChild);
          console.log(node.value);
          inOrder(localRoot.rightChild);
     }
}        
```

+ обратный (postorder)
    1. Вызов самого себя для обхода левого поддерева узла.
    2. Вызов самого себя для обхода правого поддерева узла.
    3. Посещение узла.

[к оглавлению](#Collections-Pro)

## Источники:

**Generics** 

https://docs.oracle.com/javase/tutorial/java/generics/why.html

Пришел, увидел, обобщил: погружаемся в Java Generics 
https://habr.com/ru/company/sberbank/blog/416413/

Generics в Java 1.5
http://rsdn.org/article/java/genericsinjava.xml#EQNAC

Дженерики (Generics) в java 
https://www.fandroid.info/dzheneriki-generics-v-java/

Использование generic wildcards для повышения удобства Java API 
https://habr.com/ru/post/207360/

Примеры https://o7planning.org/ru/10403/java-generics-tutorial

Александр Маторин — Неочевидные Дженерики https://www.youtube.com/watch?v=_0c9Fd9FacU

Введение в Java. Generics. Wildcards | Технострим https://www.youtube.com/watch?v=FRmgcBxJvb4

Advanced Java - Generics https://www.youtube.com/playlist?list=PL6jg6AGdCNaX1yIJpX4sgALBTmTVc_uOJ
